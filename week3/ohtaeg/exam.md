# Practice Exam
- https://explore.skillbuilder.aws/learn/course/9160

### 1번 문제
![practice-exam-1](./img/practice-exam-1.png)
```
선택 : (D)

문제 요구사항은 다음과 같다.
1. 대용량 이미지 처리시 시간 증가
2. SQS 큐로 대기열 관리하고 EC2 인스턴스에서 이미지 처리
3. 대량 요청 발생시 SQS 메세지 백로그 증가
4. 위와 같을때 성능 개선은 어떻게 할 수 있는가?
즉, 대용량 이미지 처리시, 오래걸려서 SQS의 쌓이는 메시지가 많다고 이해

A - 비용적인 면에서 최선이라고 생각하지 않음

B - 가시성은 하나의 큐에 여러 서버가 동일 메시지 처리하는 것을 방지하고자 특정 시간동안 다른곳에서 해당 메시지를 볼 수 없는 것을 뜻함
문서에 따르면 https://aws.amazon.com/ko/premiumsupport/knowledge-center/sqs-message-backlog/
SQS 메시지 백로그가 증가할 경우 오히려 가시성 시간 제한을 설정하라고 설명되어 있음 고로 B 제거

C - 헷갈린 보기였음, 이미지 처리를 EC2가 아닌 람다로 한다는 의미로 이해함. 람다를 잘 모르기에 일단 보류

D - 대용량 이미지 처리시 한 인스턴스가 처리하면 오래걸리니, 오토스케일링을 통해 크기를 조정하여 
대용량 이미지 처리하는 EC2 외에 다른 메시지를 처리할 수 있는 인스턴스를 늘리는 방법이 최선일 것 같아 D 선택
```
```
정답 : (D)

A - 전용 인스턴스를 사용하면 기존 서버 바인딩 소프트웨어 라이선스를 사용하여 비용을 절감 가능.
[하지만 서버 바인딩 라이선스는 이 시나리오에서 다루지 않음]
AWS Cloud의 장점 중 하나는 피크 소비에 맞춰서 구매할 필요가 없음, AWS Cloud는 온디맨드로 확장할 수 있다.
전용 호스트에 대한 자세한 내용은 Amazon EC2 전용 호스트 요금을 참조해볼 것.
https://aws.amazon.com/ko/ec2/dedicated-hosts/pricing/

B - FIFO 대기열은 메시지가 순서에 맞지 않게 처리될 때 발생하는 문제를 해결한다.
그러나 급격한 볼륨 증가 시 FIFO 대기열의 성능이 향상되지 않는다.
또한 [SQS 대기열을 생성한 후에는 변환할 수 없습니다.]

포인트는 이거 같다.
[기존 표준 대기열을 FIFO 대기열로 변환할 수 없습니다.]
이동하려면 애플리케이션의 새 FIFO 대기열을 만들거나 기존의 표준 대기열을 삭제하고 FIFO 대기열로 다시 만들어야 합니다.
https://docs.aws.amazon.com/ko_kr/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues-moving.html

C - 이 시나리오의 일부 파일은 처리하는 데 최대 20분이 걸릴 수 있습니다.
Lambda에는 15분의 운영 제한이 있습니다.
포인트는 [Lambda에는 15분의 운영 제한]인 것 같다.
```

<br>
<br>

### 2번 문제
![practice-exam-2](./img/practice-exam-2.png)
```
선택 : (B)

문제 요구사항
ECS 컨테이너 기반 로드(트래픽?)를 분산하는 솔루션은?
로드가 무엇일까?

A - 트래픽 분산하는 리소스는 ALB가 타당한 것 같아서 킾. 같은 작업을 경로 기반으로 나눌 순 있겠으나 최선같지 않아 제거
B - 트래픽 분산하는 리소스는 ALB가 타당한 것 같아서 킾. 기본적으로 호스트 포트 매핑을 사용하면 같은 작업을 실행할 수 있을 것 같아 선택
C - Route53과는 무관해보여서 제거 
D - Route53과는 무관해보여서 제거
```
```
정답 : (B)

A - 경로 기반 라우팅을 사용하면 여러 서비스가 단일 Application Load Balancer(ALB)에서 동일한 리스너 포트를 사용할 수 있습니다. 
ALB는 [URL 경로에 기반하여 특정 대상 그룹으로 요청을 전달]합니다. 하지만 이 솔루션은 [동일한 서비스의 여러 작업 간 로드 배포에 도움이 되지 않습니다.]

B - ALB는 컨테이너가 동적 호스트 포트 매핑을 사용하도록 허용합니다 (그래서 컨테이너 인스턴스마다 동일 서비스의 여러 작업이 허용됩니다)

C - 기본 인스턴스에 장애가 발생할 경우 장애 조치 라우팅 정책을 사용하여 트래픽을 백업 인스턴스로 라우팅할 수 있지만 [장애 조치 라우팅 정책을 사용하여 단일 컨테이너에서 여러 작업을 관리할 수는 없습니다.]

D - 가중치 기반 라우팅 정책을 사용하여 트래픽을 지정한 비율에 따라 인스턴스로 라우팅할 수 있지만 [가중치 기반 라우팅 정책을 사용하여 단일 컨테이너에서 여러 작업을 관리할 수는 없습니다.]
```

<br>
<br>

### 3번 문제
![practice-exam-3](./img/practice-exam-3.png)
```
선택 : (D)

문제 요구 사항
NLB를 사용하며 단일 AZ를 사용하는 두개의 EC2가 있을 때, 가용성을 높이는 방법은?
가용성이라 하면 장애가 나더라도 안전하게 운영할 수 있어야 한다는 뜻

A - 단일 가용 영역에 있는 인스턴스들을 말하는데, 다른 VPC의 가용영역은 별개같아서 제거
B - NLB <-> ALB 교체한다고 가용성은 그대로 일 것 같아서 제거
C - Route53 및 장애 조치 라우팅 정책과 무관한 문제 같아서 제거
D - Auto Scaling으로 가용성 확보가 적절한 것 같아서 선택
```
```
정답 : (D)
A - VPC 피어링은 다른 가용 영역에 대한 연결을 제공합니다. 하지만 [VPC 피어링은 EC2 인스턴스가 여전히 단일 가용 영역에 있기 때문에 고가용성을 보장하지 않습니다.]
B - [네트워크 로드 밸런서를 Application Load Balancer로 교체해도 가용성이 추가되지 않습니다.] 두 로드 밸런서는 기본적으로 가용성이 높습니다. 하지만 EC2 인스턴스는 두 가용 영역 간에 확장된 경우에만 가용성이 높습니다.
C - 장애 조치 라우팅에는 기본 대상과 보조(장애 조치) 대상이 필요합니다. 이 솔루션에는 장애 조치 대상이 지정되어 있지 않습니다. 또한 이 접근 방식은 EC2 인스턴스가 여전히 단일 가용 영역에 있기 때문에 고가용성을 보장하지 않습니다
```

<br>
<br>

### 4번 문제
![practice-exam-4](./img/practice-exam-4.png)
```
선택 : (A)

문제 요구 사항
S3 버킷에 문서를 저장하는데 자주 수정함. 이전 사본을 다운로드 해야하고 삭제하지 않도록 보호

A - 이전 사본을 다운로드라는 말에 버전 관리과 떠올랐고, 삭제가 되더라도 버전관리를 통해 복구 가능할 것 같아 A 선택
B - MFA 삭제와는 무관해 보임
C - 다른 리전에 복제하는 방법도 하나의 방법이겠으나 최선이라고 생각하지 않음
D - S3 Glacier 이 무엇인지는 모르겠으나 수명주기와는 무관해보임 
```
```
정답 : (A)

A - S3 버전 관리를 사용하면 동일한 S3 버킷에 객체의 여러 변형을 유지할 수 있으며 S3 버킷에 저장된 모든 버전의 객체를 모두 보존, 검색 및 복원할 수 있습니다.
또한 의도하지 않은 사용자 작업 및 애플리케이션 장애로부터 복구할 수 있습니다.

B - MFA 삭제는 추가 객체 보안 계층을 제공합니다. 또한 MFA 삭제는 객체를 삭제하는 엔터티가 승인된 MFA 토큰을 보유하도록 합니다.
하지만 MFA 삭제는 이 질문의 문서 버전 관리 요구 사항을 충족하지 않습니다.

C - S3 리전 간 복제를 위해서는 S3 버전 관리가 전제 조건입니다. 
하지만 S3 버전 관리만으로도 이 질문의 요구 사항이 충족되므로 운영 효율성이 더 높은 솔루션입니다.

D - S3 수명 주기 규칙을 사용하여 수명 주기 전반에서 비용 효율적으로 객체를 저장할 수 있습니다. 
그러나 S3 수명 주기 규칙은 이 질문의 문서 버전 관리 요구 사항을 충족하지 않습니다. 
```

<br>
<br>

### 5번 문제
![practice-exam-5](./img/practice-exam-5.png)
```
선택 : (D)

문제 요구사항
최대 15분이 걸리는 작업이 있을 때, Auto Scaling 축소 이벤트가 발생할 경우 5XX 오류가 발생하지 않도록 요청이 완료되길 원함
문제를 보고, 수명 주기 후크를 말하는건가 싶었는데 Connection Draining을 떠올림

A - 동일한 클라이언트에 동일한 인스턴스에 접속하게 해주는 스티키 세션과 무관해보여서 제거
B - 인스턴스 크기와 무관해보여서 제거
C - 휴지 기간이 무엇인지 모르겠다. 쿨다운 기간을 말하는 거같아서 제거
D - 등록 취소 지연 시간은 ALB에서 Connection Draining을 다른말로 DeRegistraion Delay로 말하기에 선택
```
```
정답 : (D)

A - 축소 프로세스 중에 EC2 인스턴스가 대상 그룹에서 제거된 경우 EC2 인스턴스에 장애가 발생하거나 비정상 상태가 됩니다(점검 시). 
Application Load Balancer는 해당 대상에 대한 요청 라우팅을 중지하고 정상적인 새 대상을 선택합니다.

B - 인스턴스 크기가 증가하면 처리 속도가 빨라질 수 있습니다.
하지만 이 솔루션은 요청을 처리하는 인스턴스가 축소 작업의 영향을 받지 않도록 직접 보장하지 않습니다.

C - Amazon EC2 Auto Scaling 휴지 기간을 지정하여 이전 활동의 효과가 나타나기 전에
Auto Scaling 그룹에서 추가 인스턴스를 시작하거나 종료하지 않도록 할 수 있습니다.
휴지 기간 : 한번의 Auto Scaling 실행 후 다음 Auto Scaling 실행까지의 시간 간격
```

<br>
<br>

### 6번 문제
![practice-exam-6](./img/practice-exam-6.png)
```
선택 : (D)

문제 요구사항
스팟 인스턴스를 사용하고 있는데, 스팟 인스턴스를 제거하기 위해선 어떻게 해야하는가?

스팟 인스턴스란 AWS 내에서 놀고있는 컴퓨터를 인스턴스로 하는 정책,
노는 컴퓨터가 많을 때는 가격이 저렴하지만 노는 컴퓨터가 없으면 일반 가격보다 비싸지는 가변적인 요금 정책

A - 보기 C, D와 달리 단일 작업만으로는 제거가 될 것 같지 않아 제거
B - 보기 C, D와 달리 단일 작업만으로는 제거가 될 것 같지 않아 제거
C - 인스턴스를 종료하고 취소를 할 수 있지 않을까해서 C 제거

스팟 인스턴스 다음과 같다.
- 스팟 인스턴스 요청은 [일회성] 또는 [영구적]입니다.
- Amazon EC2에서는 요청에 연결된 스팟 인스턴스가 종료된 후 스팟 인스턴스 요청을 자동으로 다시 제출합니다.

스팟 인스턴스 종료 정책은 다음과 같다.

[영구적 스팟 인스턴스 요청일 경우]
- 실행 중이거나 중지된 스팟 인스턴스를 종료하면 새 스팟 인스턴스를 시작할 수 있도록 스팟 인스턴스 요청이 open 상태임.
- 새로운 스팟 인스턴스가 시작되지 않도록 먼저 스팟 인스턴스 요청을 취소해야 한다.

[실행 중인 active 스팟 인스턴스 요청을 취소하는 경우]
- 실행 중인 스팟 인스턴스가 자동으로 종료되지 않습니다. 스팟 인스턴스를 수동으로 종료해야 합니다.

[중지된 disabled 스팟 인스턴스 요청을 취소하는 경우]
- 중지된 스팟 인스턴스가 Amazon EC2 스팟 서비스에 의해 자동으로 종료
```
```
정답 : (C)

A - 스팟 요청을 취소하는 것만으로는 실행 인스턴스가 자동으로 종료되지 않습니다.
이 경우 인스턴스는 계속 실행되며 추가 비용이 발생합니다.

B - 스팟 인스턴스가 종료되면 스팟 요청이 취소될 때까지 새 인스턴스가 시작됩니다.

C - 스팟 인스턴스를 제거하려면 적절한 단계에 따라 스팟 요청을 취소한 다음 스팟 인스턴스를 종료해야 합니다.

D - 스팟 인스턴스가 종료되면 스팟 요청이 취소될 때까지 새 인스턴스가 시작됩니다.
```

<br>
<br>

### 7번 문제
![practice-exam-7](./img/practice-exam-7.png)
```
선택 : (C)

인스턴스 메타 데이터가 무엇인지 처음 들음

A - A랑 C랑 고민하다가 C 선택
B - 로컬 호스트는 아닌 것 같아 제거
C - A랑 C랑 고민하다가 C 선택
D - 192.168.0.1 은 iptime 어드민 설정 들어갈때 썼던 기억이 나서 제거
```
```
정답 : (A)

A - 인스턴스 메타데이터를 검색하는 유일한 방법은 링크-로컬 주소(169.254.169.254)를 사용하는 것
B - localhost 이름을 활용하여 메타데이터를 사용할 수 없습니다.
C - 링크-로컬 주소의 형식은 169.254.169.254입니다.
D - 192.168.x.x IP 주소 범위는 퍼블릭 블록입니다. 인스턴스 메타데이터는 퍼블릭 블록을 통해 사용할 수 없습니다.

인스턴스 메타데이터 서비스의 IPv4 주소(169.254.169.254)
인스턴스 메타데이터 서비스의 IPv6 주소(fd00:ec2::254)
메타데이터 서비스의 IPv6 주소는 IMDSv2 명령과 호환
```